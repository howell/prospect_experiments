* Questions about prospect
** What are the different forms and their relation to the NC paper?
*** advertise/observe versus pub/sub
*** (?!)
*** ? (wildcard?)
*** at-meta
** How to start the program using spawn-world or spawn-demand-matcher?
** What is the pattern language?
** Is there a way to look at the current assertions? Just use printf?
** How to get the assertions out of a patch?
- A patch consists of two matchers, added and removed
- To get assertions out of a matcher, you have to decide what sort of assertions
  you are interested in, compile a pattern for those assertions, and pass that
  along with the matcher to `matcher-project/set`.
- matcher-project/set takes a matcher and a pattern and returns a set of lists
- Say you are in interested in assertions of the shape ('posn x y).
  -- compile the pattern using `(compile-projection `(posn ,(?!) ,(?!)))`
  -- the (?!) is for /capturing/ the matched value. Use ? if you want to match
     but don't care about the actual value.
  -- the lists returned by matcher-project/set contain the captured values in
     order.
- Say we are receiving a patch p where the assertion ('posn 2 3) was added.
- The result of
  `(matcher-project/set (patch-added p)
                        (compile-projection `(posn ,(?!) ,(?!))))`
  would be `(set (list 2 3))`.
- If we only cared about the y position, we could instead do
  `(matcher-project/set (patch-added p)
                        (compile-projection `(posn ,? ,(?!))))`
  and get the result `(set (list 3))`.
- `matcher-project/set/single` is like calling `set-first` on the result of
  `matcher-project/set`
- patch-project/set uses `values` to return the result of matching a projection
  against both the added and removed bits of a patch.
** What is the distinction between (assert X) and (message X)?
Time. An assertion is visible to anyone interested in it from when it is
asserted until when it is retracted. A message, on the other hand, is transient.
When a message is sent, it is delivered to everyone that is interested in it
*at that time*.
** How to inject a keyboard event into the network?
Use `send-ground-message`.
** Initial network configuration
The base layer of the network is called ground. The processes spawned at the
top level of the module are one level removed from ground as evident by the
need to use `at-meta` and #:meta-level to see messages created with
send-ground-message. Is there a way to create a ground actor? Can spawn be
wrapped with at-meta?
** Spawn a process at a specific level
In the context of a (racket) timer handler, if I call `spawn` then the process
will be at ground level. But, all of the other processes I created by calling
spawn from the top level of my module are at a different level. Is there a
direct way to spawn a process at a specific level, or do I have to create a
process at the desired level that will listen for ground-messages and spawn
processes in response?
** Why the need for patch-seq?
My intuition was that the list of actions in a transition would effectively
all be patch-seq'd together.
** Pattern of using gensym to come up with unique labels?
** Difficulty coming up with a protocol for the "platformer"
*** really just moving two pictures around a canvas with collision detection).
*** Where should the state of each entity be?
*** Seems ugly to always be retracting assertions - might as well just use messages
*** Take 1: mimic big-bang program completely?
**** one process holds on to all the state and does everything!
*** Idea: one process for each 'thing' in the world
Have a process for each shape that asserts the position where it wants to be.
One other process listens for all these assertions and then decides where
everything actually is.
**** Problem with trying to assert the same thing multiple times before the game logic process can catch up
*** Take 2: one process for each dot plus a process for drawing
- each dot process P asserts its current location as ('shape shape) and listens
  for the location of every other thing.
- to move from shape to shape', P retracts ('shape shape) and asserts
  ('shape shape'). P should only assert shape'if it does not collide with any
  other asserted shape.
- a drawing process D listens for every location and draws/erases to the screen
  as postions are asserted and retracted.
*** Take 3: collision detection
- key board events are injected into the system using messages of the form
  ('key-event k)
- each dot process has a unique label P and asserts its current location as
  ('shape P shape).
- To move from shape to shape', P retracts ('shape P shape) and asserts
  ('shape P shape').
- A collision detection process listens for ('shape ? ?) assertions and
  maintains a state of where everything is. If a collision is detected between
  dots P and Q, the process sends a message ('move L dx dy) to one of P or Q,
  where dx and dy are randomly chosen.
- When a dot P receives a move message it updates its assertions to reflect the
  new location.
- a drawing process D listens for every location and draws/erases to the screen
  as postions are asserted and retracted.
*** TODO Improvement needed: deliberate, instead of random, collision reaction.
*** Take 4: motion messages
- key board events are injected into the system using messages of the form
  ('key-event k)
- each dot process has a unique label P and asserts its existence with
  ('shape P shape).
** Strange error message
   ../prospect/prospect/lang.rkt:27:26: syntax-local-lift-module-end-declaration: not currently transforming an expression within a module declaration
*** Apparently the result of using `(module+ test ...)`
** Am I cheating by calling directly into racket/gui and racket/draw so often?
** What processes can I spawn within a `(parametrize current-eventspace ...)`
Seemed to have problems with prospect_moving_dots2.rkt spawning dot processes
within that context
** Can't include a message or spawn in the initial list of actions passed to `spawn`?
** Why aren't messages just folded in to patches when delivered to a behavior?
** What happens if multiple processes assert the same thing?
Does the event show up multiple times in a patch?
** It feels like their is some duplication in the way patches are handled.
In order for an assertion to be included in a patch to a process, it needs to
be tested against the patterns that process is interested in. But, once the
patch is delivered, the process has to run each pattern against the patch to
recover the shape of each assertion.
** How to create a tiered network?
** Can a message be included as an initial action in a process? should it?
