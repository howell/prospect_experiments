* Questions about prospect
** What are the different forms and their relation to the NC paper?
*** advertise/observe versus pub/sub
*** (?!)
*** ? (wildcard?)
*** at-meta
** How to start the program using spawn-world or spawn-demand-matcher?
** What is the pattern language?
** Is there a way to look at the current assertions? Just use printf?
** How to get the assertions out of a patch?
** What is the distinction between (assert X) and (message X)?
Time. An assertion is visible to anyone interested in it from when it is
asserted until when it is retracted. A message, on the other hand, is transient.
When a message is sent, it is delivered to everyone that is interested in it
*at that time*.
** How to inject a keyboard event into the network?
** Initial network configuration
The base layer of the network is called ground. The processes spawned at the
top level of the module are one level removed from ground as evident by the
need to use `at-meta` and #:meta-level to see messages created with
send-ground-message. Is there a way to create a ground actor? Can spawn be
wrapped with at-meta?
** Spawn a process at a specific level
In the context of a (racket) timer handler, if I call `spawn` then the process
will be at ground level. But, all of the other processes I created by calling
spawn from the top level of my module are at a different level. Is there a
direct way to spawn a process at a specific level, or do I have to create a
process at the desired level that will listen for ground-messages and spawn
processes in response?
** Why the need for patch-seq?
My intuition was that the list of actions in a transition would effectively
all be patch-seq'd together.
** Pattern of using gensym to come up with unique labels?
** Difficulty coming up with a protocol for the "platformer"
*** really just moving two pictures around a canvas with collision detection).
*** Where should the state of each entity be?
*** Seems ugly to always be retracting assertions - might as well just use messages
*** Take 1: mimic big-bang program completely?
**** one process holds on to all the state and does everything!
*** Idea: one process for each 'thing' in the world
Have a process for each shape that asserts the position where it wants to be.
One other process listens for all these assertions and then decides where
everything actually is.
**** Problem with trying to assert the same thing multiple times before the game logic process can catch up
*** Take 2: one process for each dot plus a process for drawing
- each dot process P asserts its current location as ('shape shape) and listens
  for the location of every other thing.
- to move forme shape to shape', P retracts ('shape shape) and asserts
  ('shape shape'). P should only assert shape'if it does not collide with any
  other asserted shape.
- a drawing process D listens for every location and draws/erases to the screen
  as postions are asserted and retracted.
** Strange error message
   ../prospect/prospect/lang.rkt:27:26: syntax-local-lift-module-end-declaration: not currently transforming an expression within a module declaration
*** Apparently the result of using `(module+ test ...)`
** Am I cheating by calling directly into racket/gui and racket/draw so often?
** What processes can I spawn within a `(parametrize current-eventspace ...)`
Seemed to have problems with prospect_moving_dots2.rkt spawning dot processes
within that context
